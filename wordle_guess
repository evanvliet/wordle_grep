#!/bin/bash
# A comand line wordle player, prints suggested word.
#
# wordle_guess <green letters> <yellow letters> <black letters>
#
# Uses sed to find matches to a green, yellow, black specification. The
# specification is three strings for the green, yellow, and black
# characters on the last wordle puzzle line. Examples:
#
# <green letters>   e.g., ..a.b if 3rd and 5th letters are green a and b
# <yellow letters>  e.g., .e.h  if 2nd and 4th letters are yellow e and h
# <black letters>   e.g., jks   if j, k, and s all are black
#
# Use a dot (.) as a place holder, as position is significant for green
# and yellow letters. A plain dot means no color character at that spot.
# 
# Saves the sed output of matching words in local file for next guess.
# 
# Proceeds to pick a guess from this output. Looks for a word that has
# the most characters in common with other possible matches.  Considers
# most common letters among the matches first. For each character finds
# matches with that letter. If some exist,  use the result for further
# pruning. Prints the final smallest subset.
# 
# Called without arguments, it scans a word list from the pre-New York
# Times version of wordle, saved as $BASH_SOURCE.dat, e.g.
# wordle_guess.dat. In this case the above algorithm for picking a
# guess suggests "arose" - an ok choice.

FULL_LIST=$BASH_SOURCE.dat
WORD_LIST=wg_last
SED_OUTPUT=$(mktemp)
SED_COMMANDS=$(mktemp)

# use full word list if no args so new puzzle
test -n "$1" || rm -f $WORD_LIST
test -s $WORD_LIST || cp $FULL_LIST $WORD_LIST

# set up sed commands
echo "/^${1:-.}/!d" >$SED_COMMANDS # match green characters
echo "/[${3:-.}]/d" >>$SED_COMMANDS # delete words with black characters
# yellow characters more tricky
dots='' # to specify position
for yellow in $(grep -o . <<<${2:-.}); do
    if test $yellow != '.'; then
        echo /$yellow/!d # delete lines without yellow
        echo /^$dots$yellow/d # delete words with yellow at same spot
    fi
    dots=$dots. # add dot to position
done >>$SED_COMMANDS

# get possible matches
sed -f $SED_COMMANDS $WORD_LIST >$SED_OUTPUT
cp $SED_OUTPUT $WORD_LIST # save for next guess

# get letters in order most frequent first
letters=$(grep -o . $SED_OUTPUT | sort | uniq -c | sort -nr | tr -d '[0-9]')
SED_TMP=$(mktemp) # subset containing letter
for letter in $letters; do
    grep $letter $SED_OUTPUT >$SED_TMP && mv $SED_TMP $SED_OUTPUT
done
cat $SED_OUTPUT # suggested guess

# clean up
cp $SED_COMMANDS wg.sed
rm -f $SED_TMP $SED_OUTPUT $SED_COMMANDS
