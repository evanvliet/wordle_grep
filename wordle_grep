#!/bin/bash
# A comand line wordle player, prints suggested word.
# 
# wordle_grep <green letters> <yellow letters> <black letters>
# 
# For first word, scans a word list from the pre-New York Times version
# of wordle. It is in wordle_grep.dat, hence $BASH_SOURCE.dat.
# Subsequent uses scan list of matches from previous one.
#
# Uses sed to find matches to a green, yellow, black specification. The
# specification is three strings for the green, yellow, and black
# characters on the wordle puzzle line. Examples:
# 
# <green letters>   e.g., ..a.b if 3rd and 5th letters are green a and b
# <yellow letters>  e.g., .e.h if 2nd and 4th letters are yellow e and h
# <black letters>   e.g., jks if j, k, and s all are black
# 
# Use a dot (.) as a place holder, as position is significant for green
# and yellow letters.
# 
# A plain dot means no color character at that posititon.
# 
# Proceeds to pick a guess from the sed output. Looks for a word
# that has the most characters in common with other possible matches.
# Considers characters, most common among the matches, first. For each
# character finds matches with that letter. If none, skips the
# character. Otherwise use the result for further pruning. Whatever
# word is left at the end is the guess.  With no arguments, scans full
# word list. The winner is "arose" - a good first guess. Word list is
# refined, only last line need be specified.  To force refresh, use
# without arguments.

SED_INPUT=wordle_grep.now
MATCHES=wa.1

# reuse last SED_INPUT unless starting new puzzle
test "aeors" = "$(echo ${*:-arose} | grep -o . | sort | tr -cd '[a-z]')" && \
    rm -f $SED_INPUT  # new puzzle if no args or arose first guess
test -s $SED_INPUT || cp $BASH_SOURCE.dat $SED_INPUT  # default full word list

SED_COMMANDS="-e /^${1}/!d -e /[${3:-=}]/d" # match greens and exclude blacks
PREFIX_DOTS='' # initialize prefix dots needed for yellow character filtering
for YELLOW_LETTER in $(grep -o . <<< ${2:-.}) # for yellow letter in second argument
do # if not dot add filters
    if [ $YELLOW_LETTER != '.' ]
    then
        # delete words without yellow char
        SED_COMMANDS="$SED_COMMANDS -e /$YELLOW_LETTER/!d"
        # delete words with yellow character in same position
        SED_COMMANDS="$SED_COMMANDS -e /^$PREFIX_DOTS$YELLOW_LETTER/d"
    fi
    PREFIX_DOTS=$PREFIX_DOTS. # to delete words with character at same position
done
sed $SED_COMMANDS $SED_INPUT > $MATCHES
cp $MATCHES $SED_INPUT # save for next guess

# find guess with most letters in common with matches

# use grep -o to get all letters in matches
# sort, count with uniq, and sort numerically so most common first
# and use tr to remove counts, just want letters in order
for i in $(grep -o . $MATCHES | sort | uniq -c | sort -nr | tr -d '[0-9]')
do  # prune matches with most common letters first
    grep $i $MATCHES > $MATCHES.letter && mv $MATCHES.letter $MATCHES
done
cat $MATCHES
rm -f $MATCHES.letter $MATCHES
